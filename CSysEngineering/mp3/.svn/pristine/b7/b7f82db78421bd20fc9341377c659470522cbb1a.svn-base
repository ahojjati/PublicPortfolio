//contains the handler for the rtc
//possibly an initialization function 
// anything rtc related

#include "i8259.h"
#include "lib.h"
#include "rtc.h"

static uint32_t interrupt_flag = 0;

/*
 * rtc_init
 * Description: sets up the RTC and enables the IRQs on the appropriate PICs
 * Inputs: none
 * Outputs: none
 * Returns: none
 * Side Effects: Enables IRQs 2 and 8; initializes the frequency and divsisor for RTC 
 */
void rtc_init()
{
	uint32_t flags;
	uint8_t prev;

	cli_and_save(flags);

	// open appropriate IRQs
	enable_irq(RTC_IRQ);
	enable_irq(SLAVE);

/*
	// set rate value in Register A
	outb(RTC_REG_A, RTC_PORT);
	outb(SLOW, RTC_DATA);
*/

	// grab previous value of register B
	outb(RTC_REG_B, RTC_PORT);
	prev = inb(RTC_DATA);

	// write to register B and turn on bit 6 of it
	outb(RTC_REG_B, RTC_PORT);
	outb(prev | BIT_SIX, RTC_DATA);

	interrupt_flag = 0;

	restore_flags(flags);
	
	
}

/*
 * rtc_idt
 * Description: handler for the RTC that calls test_interrupts
 * Inputs: none
 * Outputs: none
 * Returns: none
 * Side Effects: clears regsister C in RTC so RTC interrupts can come again
 */
void rtc_handler_c()
{
	//****Comment this out since rtc interrupts are working
	//test_interrupts();

	interrupt_flag = 1;

	// clear register C
	outb(RTC_REG_C, RTC_PORT);
	inb(RTC_DATA);

	send_eoi(RTC_IRQ);
}


/*
 * rtc_open
 * Description: sets the RTC interrupt frequency to 2Hz
 * Inputs: none
 * Outputs: none
 * Returns: 0 on succcess, -1 on failure (?)
 * Side Effects: shifts contents of register A down appropriately so 2Hz interrupt generated
 */
 int32_t rtc_open(uint8_t* buffer, int32_t count)
 {
 	uint32_t flags;
 	cli_and_save(flags);

 	// Set the divisor value in register A so that interrupts come at 2 Hz
 	outb(RTC_REG_A, RTC_PORT);
	outb(SLOW, RTC_DATA);

	restore_flags(flags);

	return SUCCESS;

 }

 /*
 * rtc_close
 * Description: return 0
 * Inputs: none
 * Outputs: none
 * Returns: 0 constantly
 * Side Effects: none
 */
 int32_t rtc_close(uint8_t* buffer, int32_t count)
 {
 	return SUCCESS;
 }

 /*
 * rtc_read
 * Description: wait for an interrupt to be generated by RTC before returning
 * Inputs: none
 * Outputs: none
 * Returns: 0 on succcess, -1 on failure (?)
 * Side Effects: resets the interrupt_flag back to 0
 */
 int32_t rtc_read(uint8_t* buffer, int32_t count)
 {
 	interrupt_flag = 0;
 	while(!interrupt_flag) 
 	{
 		// wait for interrupt and do nothing
 	}
 	//printf("Interrupt received\n");
 	return SUCCESS;
 }

 /*
 * rtc_write
 * Description: sets the RTC interrupt frequency to whatever is specifed in buffer
 * Inputs: none
 * Outputs: none
 * Returns: 0 on succcess, -1 on failure (?)
 * Side Effects: shifts contents of register A down appropriately so new frequency interrupt generated
 * Note: Wrting to register A (rate); frequency = 32768 >> (rate - 1);
 */
 int32_t rtc_write(uint8_t* buffer, int32_t count)
 {
 	int32_t divisor;

 	divisor = (int32_t)buffer[0];
 	// Limit user capabilities of setting frequency from 2 Hz to 1024 Hz
 	if(divisor >= MIN_DIV && divisor <= MAX_DIV)
 	{
 		uint32_t flags;
 		cli_and_save(flags);

 		// write to register A in RTC to set the appropriate frequency
 		outb(RTC_REG_A, RTC_PORT);
 		outb(buffer[0], RTC_DATA);

 		restore_flags(flags);
 		return SUCCESS;
 	}
 	return FAILURE;
 }
